---

---

💡🚀🤟👉👇☀️🍉🍍🍇🍓🥕🍭🎖️🎁☘️🍀💯🔆❗🔥🚩

### axios二次封装

步骤：

 	1. 在 src 文件下建立 *utils*文件夹，在该文件夹下建立 *request.js*文件，在该文件中配置包括 baseURL、请求拦截器、响应拦截器，以下以配置 baseURL为例：

```js
// 封装全局公共axios请求
import axios from "axios"  // 引入axios插件
// 通过axios.create()导出出多个(根据需求)带有不同根路径的axios
export const request1 = axios.create({
    baseURL: 'http://localhost:3000'
})
// request1 相当于一个带有一个根路径为'http://localhost:3000'的axios
export const request2 = axios.create({
    baseURL: 'http://localhost:8080'
})

....
```



 	2. 在 src 文件下建立 *api*文件夹，在该文件夹下建立 *对应业务.js*文件，在文件中：

```js
// 如：歌单模块列表接口

// 1.导入axios配置
import { request1 } from "../utils/request.js"

// 2.创建接口方法并导出
export const getPersonalized = () => request({
    method: 'GET',
    url: '/personalized'
})
```



 	3.  在 src 文件下建立 *api*文件夹，在该文件夹下建立 *index.js*文件 (该文件为所有业务的统一出口文件，所有业务的接口都要导入该文件，然后再导出) ，在文件中：

```js
// 统一导出api接口出口文件

// 1.导出对应业务接口
import { getPersonalized } from './songList'

// 2.导出对应业务接口
export const getPersonalizedAPI = getPersonalized
```



 4. 之后就可以在对应业务vue组件中使用该接口，使用该接口时，通过 async 和 await 来处理promise的异步操作，减少嵌套层级(回调地狱)；

    使用 async 和 await 需要手动抛异常，通过 try  catch 的方法：

```vue
<template>
  <div> </div>
</template>

<script>
	// 导入歌单列表api
import { getPersonalizedAPI } from '../../api/index'

export default {
  name: 'home-index',
  data () {
    return {
      // 歌单列表
      songList: []
    }
  },

  async created () {
    try {
      // 获取初始数据
      let res = await getPersonalizedAPI()
      console.log(res.data.result)
      this.songList = res.data.result
    } catch(error) {
      console.log(error)
    }
  },
}
</script>

<style scoped>

</style>
```



### 项目中js代码的拆分步骤(以router的配置为例)

为什么需要js代码拆分？拿main.js 来说，实际项目中会有大量的js代码存在与其中，如果全部写在main.js中会让其阅读性很差（本来就是入口文件，不要太复杂的代码结构）

​	步骤：

```js
/* 
  拆分js的步骤
  1. 复制需要拆分的代码放到新的js文件中
  2. 查看复制后代码报错部分（报错的原因： 没有引入相关的依赖方法）
  3. 在js的最后一般情况下，都会有某一个变量没有被使用而报错， 需要通过 export default 进行导出
  4. 查阅当前js拆分文件中引入其他文件时的路径
  5. 在原来的文件中，通过import引入的方式，进行方法的引入 （原文件一定有一个地方因为找不到声明的变量而报错，引入的方法、数据时的命名，就以报错的这个变量来命名）
*/
```

​	以main.js中组件路由配置的js代码为例（实际工作中也是这么拆分的）：

1. 在 src 下新建  *router*文件夹，在router文件夹下建立 *index.js*文件，再将原本写在 main.js 文件中的配置组件路由部分代码剪切到 index.js 文件中：

```js
// 1. 下载对应版本的vue-router依赖包

// 2. 引入vue-router
import VueRouter from 'vue-router'
import Vue from 'vue' // 引入vue

// 3. 使用VueRouter
Vue.use(VueRouter)

// 4. 引入对应业务组件,创建规则数组
import Home from '../views/Home/home.vue'
import Layout from '../views/Layout/layout.vue'
import Play from '../views/Play/play.vue'
import Search from '../views/Search/search.vue'

let routes = [
  {
    path: '/', 
    redirect: '/layout'  
  },  // 开启项目时，重定向到layout首页
  {
    path: '/layout',
    component: Layout,
    redirect: '/layout/home', // 刚进入layout一级路由时，立即定向到home组件
    children: [
      {
        path: 'home',
        component: Home,
        meta: {  // meta 为路由的一些静态数据的挂载点
          title: '首页'  
        }
      },
     ]
   },
  {
    path: '/play',
    component: Play
  }
]

// 5. 创建router实例
let router = new VueRouter({
  routes
})

// 6. 默认导出router
export default router

// 7. 在main.js中引入并挂载到vue实例中去（$route）

// 8. 使用对应组件使用只需要在组件对应位置放置 <router-view></router-view> 标签即可；
```

2. 在main.js的文件中引入 router ，再挂载到 vue 实例对象中：

```js

import router from './router/index.js'

new Vue({ // 实例化vue对象
  router, // 6. 挂载到vue对象中
  render: h => h(App),
}).$mount('#app') 

```



### 组件在文件夹内的存放规则

```js
/* 
  views页面组件文件夹内部布局
  1. 页面组件 => 跟路由绑定在一起的组件 => 就可以为views文件夹中的一个文件夹
  2. 功能组件
    2.1 全局功能组件 - 如： 顶部导航组件 => 放在src/components
    2.2 业务专属功能组件 - 该组件的目的主要是去拆分代码，次要目的是区分功能 => 放在对应*页面组件*文件夹下的components文件夹下 
        如： src/views/home/components
*/
```

