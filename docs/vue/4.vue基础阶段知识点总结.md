# 复习

## 一. vue中标签上的一些基本语法

1. 插值表达式

   ```vue
   {{ 表达式 / 变量 / 带有返回值的方法( 例如: fn() ) }}
   ```

2. v-bind 动态属性

   ```vue
   <span v-bind:属性名="属性值"></span>
   <span :属性名="属性值"></span>
   
   <子组件 :自定义属性名="属性值"></子组件>
   ```

3. v-on 绑定事件

   ```vue
   <span v-on:事件名="绑定该事件的方法"></span>
   <span v-on:click="fn"></span>
   <span @click="fn"></span>
   ```

4. v-on 的事件对象 event

   - 如果事件绑定的方法没有额外的实际参数，则在事件绑定时不必写 `小括号`，事件对象默认会放到第一个形参的位置上

     ```
     <span @click="fn"></span>
     
     fn (event) {}
     ```

   - 如果事件绑定的方法有额外的实际参数，以`$event`的形式，放到所有实际参数的最后面

     ```
     <span @click="fn(1, 2, 3, $event)"></span>
     
     fn (num1, num2, num3, event) {}
     ```

5. v-on的事件修饰符

   - once 绑定的事件只有第一次有效
   - **prevent** 阻止默认事件
   - **stop** 阻止冒泡（阻止事件委托）

6. v-on的按键修饰符 - 记录键盘按下的事件

   - esc 键盘左上角的返回键 - 清空输入框内容
   - enter 回车 - 自动提交表单

7. v-model - 用在表单元素上,实现数据与视图的双向绑定

8. v-model的修饰符

   - .trim 去除前后空格 
   - .number 只能输入数字，如果说最开始的那个字符不能解析为数字时，整个`.number`修饰符会失效
   - .lazy 输入框原本每做一次修改都会引起数据与视图的双向绑定，当设置了这个修饰符时，只有当输入框发生change事件(可以理解为：敲击回车，失焦)时，才去触发数据与视图的双向绑定

9. v-show v-if

   - v-show  是用过css样式`display: none`来显示隐藏和显示的
   - v-if v-else-if v-else 是通过删除和添加dom树来进行显示和隐藏的

   当需要显示和隐藏的结构均为静态数据时，那么选择v-show，除此以外均选择v-if

10. v-text 和 v-html

    - v-text => innerText
    - v-html => innerHTML

    当设置了这两个指令后，这个标签内不能写任何内容

11. v-for

    循环可遍历的数据结构，减少dom操作

    ```
    v-for="(value, index) in 数据结构" :key="index"
    ```

    在数据循环的过程中，需要为被循环的标签设置key属性，这个属性的设置规律： 有id用id，没id用索引，id报错用索引。

12. MVVM设计模式

    - 修改数据时，视图自动同步
    - 修改视图时，数据自动同步

    model - 数据模型 - 例：data中定义的数据

    view - 视图 - 例：表单控件

    viewModel - viewModel视图模型  vue内置的源码黑盒

13. MVC设计模式

    model - 数据模型 - 例：data中定义的数据

    view - 视图 - 例：表单控件

    controller 控制器

    通过方法或事件通知controller 控制器，又控制器去修改数据与视图(操作dom修改)

## 二. 进阶动态属性

1. 动态class类

   ```
   // 展示或隐藏特定类名
   :class="{ 类名: 布尔值 / 可隐式转化为布尔值类型的数据(变量和表达式) }"
   
   // 切换不同的类名
   :class="[ 携带样式类名的变量 ]"
   ```

2. 动态style

   ```
   // 特定样式属性进行样式转化
   :style="{ css样式属性名: 携带 当前样式属性专属的属性值 的变量 }"
   
   // 当需要切换不同种样式结构时
   :style="[ 以对象形式携带 样式属性(键值对) 的变量 ]"
   ```

## 三. 过滤器filter

> 转化页面中某些数据个格式。 过滤器就是一个函数，传入值并返回处理后的值，不会修改源数据

```
// 全局过滤器
Vue.filter('自定义过滤器名称', (需要过滤处理的数据源, 使用时传递过来的参数) => { return '返回处理后的值' })

// 局部过滤器
在data的同级
filers: {
	'自定义过滤器名称' (需要过滤处理的数据源, 使用时传递过来的参数) {
		return '返回处理后的值'
	}
}

=> 如果过滤时的处理方式并不复杂（一行代码搞定），可以直接在插值表达式中书写该逻辑即可，不必使用过滤器
```

## 四. 计算属性computed

> 场景：当页面上某一个变量会受到一个或多个变量的影响(计算)得来时，可以使用计算属性来实现代码的简化

特点： computed 计算属性存在缓存机制， 当依赖项没有发生改变时，去使用对应的计算属性，那么不会重复计算而是冲缓存中直接获取结果

```
// 基本写法
computed: {
	'计算属性名称' () {
		// 各个依赖项的处理逻辑
		return '计算后的值'
	}
}

// 完整写法 - 全选小选
computed: {
	'计算属性名称': {
		// 一般情况下，在表单控件中主动修改计算属性的值时，会触发set方法
		set (value) {
			value表示的是当前计算属性的值
		},
		// get方法就是基本写法的格式和作用
		get () {}
	}
}
```

## 五. 监听器 watch

> 场景： 当某个数据需要它修改时，去影响其他一个或多个数据时，可以使用监听器去监听当前数据的变化

特点： 监听器是一个对象，键时需要观察的变量属性，值是一个回调函数，主要用于监听某些特定数据的变化，从而进行某些具体的业务操作。监听操作对性能是有所消耗的，在使用时尽量少用。

```
// 基础写法
watch: {
	'被监听的变量名' (newVal, oldVal) {
		// 更新后的值 - newVal
		// 更新前的值 - oldVal
	}
}

// 当发现监听不到数据变化时改为深度监听
watch: {
	'被监听的变量名': {
		handler (newVal, oldVal) {
            // 更新后的值 - newVal
            // 更新前的值 - oldVal
        },
        deep: true, // 开启深度监听
        immediate: true // 当页面载入时立即执行一次监理handler的方法
	}
}

// 无论监听什么数据， 先用基本写法进行监听，如果监听不到数据的改变，则转化为深度监听
// 如果业务需求不需要比较新旧参数的变化时，可以不传任何参数
```

## 六. 组件通信

![image-20220929103208956](images/image-20220929103208956.png)

## 七. 组件的进阶用法

### 7.1 动态组件

1. 动态组件一定有is属性（必填）
2. is属性必须是动态属性，且它的属性值必须是一个变量
3. 记录组件名称的变量记录的是 components对象中注册的组件的属性名

```vue
<component :is="记录组件名称的变量"></component>
```

如果动态组件切换时希望浏览器能够记住切换前的组件状态，那么可以用`<keep-alive>`来进行组件缓存

```vue
<keep-alive>
	<component :is="记录组件名称的变量"></component>
</keep-alive>
```

### 7.2 组件插槽 - 工作中用的少

>  （当公司达到一定水平 - 你的薪资达到一定水平时，使用的频率才会上升）

1. 插槽的基本用法

   子组件

   1. 在需要自定义的位置上设置`<slot></slot>`插槽标签， 为父组件中灵活设置的结构占位

   ```vue
   <div>
       <slot></slot>
   </div>
   ```

   父组件

   1.  在子组件双标签中，设置对应性自定义结构，即可显示到子组件定义的插槽位置

   ```vue
   <child>
   	<div>自定义内容</div>
   </child>
   ```

2. 插槽的默认值

   > 场景: 又是其实在使用某个子组件时，会有一些公共相同的内容，而真正需要对该内容做出修改的机会比较少

   子组件

   1. 在原有`<slot></slot>`标签内，设置应有的默认结构即可

   ```vue
   <div>
       <slot>
       	默认值
       </slot>
   </div>
   ```

   父组件

   1. 如果需要用到子组件插槽的默认值，这不用在子组件的标签中设置任何内容即可

   ```vue
   <child></child>
   ```

3. 具名插槽

   > 场景： 当子组件中有多个位置都需要父组件来灵活配置时，可以为`slot`标签设置name属性。

   子组件

   1. 为`<slot>`标签设置name属性

   ```vue
   <div>
       <slot name="title"></slot>
       <slot name="content"></slot>
   </div>
   ```

   父组件

   1. 子组件的双标签中，以`<template></template>`中设置`v-slot:插槽名称 或者 #插槽名称`的方式来确定插入的位置

   ```vue
   <child>
   	<template v-slot:title></template>
       <template #title></template>
   </child>
   ```

4. 作用域插槽

   > 场景： 当父组件中子组件插槽部分需要用到某些子组件中的数据时，需要用作用域插槽进行参数的传递

   子组件

   1. 在`<slot>`标签中，设置 `:自定义属性="子组件中的数据变量"` 来进行插槽的参数传递

   ```vue
   <div>
       <slot name="title" :obj="myObj" :row="myRow"></slot>
   </div>
   ```

   父组件

   	1. 在原本具名插槽`<template v-slot:插槽名称 />`后以等号的形式，创建自定义变量（scope）， 该自定义变量以对象的形式包含了所有当前具名插槽中所设置的自定义属性及对应的值

   ```vue
   <child>
   	<template v-slot:title="scope">
   		{{ scope.obj }}
   		{{ scope.row }}
       </template>
   </child>
   ```

## 八. 生命周期

> 5个阶段 10个方法

1. 初始化阶段

   beforeCreate - 数据方法什么都没有，做不了操作

   **created** - 可以操作数据和方法(在此时可以调用接口获取数据，也可以定义全局事件和方法)

   ​				 不可以进行dom操作

2. 挂载阶段

   beforeMount - 可以进行操作与created相同，但时间相对滞后，所以一般不用

   **mounted** - 既可以操作数据和方法，也可以操作dom元素

   ​				 当你不太好确定某个方法是否需要进行dom操作时，就直接丢在mounted中

3. 激活阶段

   只有动态组件放在keep-alive中进行缓存时，才会触发激活阶段的钩子函数

   activated - 激活时，只要存在缓存，就将created和mounted中的逻辑放到这里即可

   deactivated - 失活时，如果当前组件存在定时器时，将beforeDestroy中的逻辑放到这里即可

4. 更新阶段

   beforeUpdate - 更新前，数据修改了，但页面没修改

   updated - 更新后，数据修改了，但页面也更新了

   问题：在更新阶段时，如果又对数据进行了修改操作，那么又会产生新的更新阶段，会有死循环的风险。 所有当我们需要对某个值变化时去影响其他的值时，使用watch监听器来进行即可

5. 销毁阶段

   **beforeDestroy** - 销毁前，可以进行数据方法的操作和dom元素的获取，在此时需要关闭定时器，计时器，异步操作等

   destroyed - 销毁后，数据方法和dom已经销毁掉了，不用做任何操作



## 九. axios

```
axios({
	method: 'GET',
	url: '',
	params: {}
})
// get请求的参数会记录到url上

axios({
	method: 'POST',
	url: '',
	data: {}
})
// post请求的参数只会记录到请求体中
```



## 十. $nextTick

> 场景： Vue页面DOM的更新是异步的 (数据与页面存在延时)， 正因为如此，我们无法在第一时间获取到最新的dom元素

```
this.$nextTick(() => {
	// dom更新后需要执行的代码逻辑
})
```

实现原理：  `$nextTick`是 在dom元素更新后所执行的回调函数，所以说`$nextTick`是dom异步更新的回调函数它本身不应该认为是异步方法

使用时：`$nextTick`需要写在函数执行体的最后



扩展： `setTimeout(() => {}, 0)`也能解决dom异步渲染后的业务操作

原理： 即使是异步操作，它也需要在异步操作的队列里等待前一个异步操作执行完成，所以说就可以创建一个新的异步方法放到原本dom更新的异步操作后，当dom更新异步操作完成以后，就可执行下一个异步方法了

## 十一. vue文件中的基本常识

### 11.1 组件中的data是一个函数

​			因为组件是可以拿来复用的，但js中的对象是引用关系，如果data是一个对象，当一个组件被复用时，那么每个组件会共同引用同一个对象，当一个组件中对这个对象中的数据进行修改时，那么另外一个组件中的数据也会被相应修改，这样会造成一个数据污染的问题；但是当data是一个函数的时候，组件被复用时，每复用一次data就会返回一个新的数据对象，这样每个被复用的组件就拥有各自的数据对象，就不会造成这个数据污染问题；



### 11.2 style标签中scoped属性的作用

作用： 让当前style标签中的样式属性只作用于当前的`template`模板标签中

原理：

1. 为每一个组件实例生成一个唯一的标识组件的标识符
2. 通过这个标识符，为`<template>`模板中的每一个dom元素以及在这个模板中的子组件的根标签设置以`data-v-`开头，后面接上唯一标识符的标签属性： 例如： `data-v-e0djsk23`
3. 在style标签上设置的各个css样式属性均会自动的在*选择器*的后面添加一个*属性选择器*`[data-v-e0djsk23]`，通过该操作就可以保证只有当前的这个组件会受到样式的影响

### 11.3 简单描述一下vue的设计模式

参考答案：

​		vue使用的mvvm设计模式；

​		MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel；Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁（vue实例） ；

​		数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。 双向绑定的描述；



### 11.4 简述nextTick实现原理

参考答案：

​		1. nextTick是Vue提供的一个全局API（内置方法），是下次DOM更新循环结束之后执行的延时回调，在修改之后使用$nextTick，则可以在回调中获取更新后的DOM进行对应的操作；

​		2.vue在更新DOM时是异步执行的。只要侦听到数据变化，vue将开启1个队列，并缓存在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会推入到队列中1次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的DOM操作完成后才调用。

### 11.5 计算属性computed与侦听器watch的区别

参考答案：

​		computed计算属性：该属性的结果会被缓存，当computed中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用computed中的函数必须用return返回最终的结果，computed更高效，优先使用

​		watch属性监听： 是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，监听属性的变化，需要在数据变化时执行异步或开销较大的操作使用。

​		使用场景：computed当一个属性受多个属性影响的时候使用 （多对一），例：购物车结算功能； watch当一条数据影响多条数据的时候使用（一对多），例：搜索数据。

## 十二. 路由 - （vue-router）

### 12.1 路由的创建

1. 下载vue-router依赖， 注意版本

   - vue2 => npm i vue-router@3.5.1
   - vue3 => npm i vue-router

2. 引入路由

   ```
   import VueRouter from 'vue-router'
   ```

3. 使用路由

   ```
   Vue.use(VueRouter)
   ```

4. 创建规则数组

   ```js
   // 引入组件
   import Demo from '@/Demo.vue'
   import Child from '@/Child.vue'
   import NotFound from '@/NotFound.vue'
   // 创建规则数组
   let routes = [
    	{
    		path: '/', // 根路由
           redirect: '/demo' // 重定向到目标路由
    	},
       {
           path: '/demo',
           component: Demo,
           children: [ // 子路由部分
               {
                   path: 'child',
                   component: Child
               }
           ]
       },
       {
           path: '*',
           component: NotFound
       }
   ]
   ```

5. 创建router实例对象

   ```
   let router = new VueRouter({
   	routes
   })
   ```

6. 在实例化Vue中引入路由

   ```
   New Vue({
   	router,
   	render: (h) => h(App)
   	....
   })
   ```

### 12.2 路由的使用

1. 声明式导航

   通过`router-link`标签实现编程式导航的路由跳转（相当于a标签）

   - 发送：`<router-link to="/path?属性名1=属性值1&属性名2=属性值2" />`

     接收：`$route.query.属性名`

   - 发送：`<router-link to="/path/属性值" />`

     ​			需要在路由规则数组中的path属性定义 `path: '/path/:属性名'`

     接收： `$route.params.属性名`

2. 编程式导航

   - 发送： `$router.push({ path: '/path', query: { 携带参数的键值对 } })`

     query传参的参数会记录在url上以`?属性名=属性值`的形式

     接收： `$route.query.属性名`

   - 发送： `$router.push({ name: 'pathName', params: { 携带参数的键值对 } })`

     params传参的参数不会记录到url上，并且刷新页面以后参数就会丢失

     接收： `$route.params.属性名`

3. 在组件中如何设置

   通过`<router-view></router-view>`标签来作为路由组件的替换标签，确定路由组件所影响的位置。

4. 路由的`meta`属性

   当某些路由需要携带一些**静态**数据时，可以不用通过路由传参来传递，可以设置在路由规则数组的meta属性下，那么当需要使用的时候，通过`$route.meta`来获取

   ```js
   let routes = [
   	{
   		path: '/home',
           component: Home,
           meta: {
               title: '首页',
               content: '推荐首页'
           }
   	}
   ]
   ```































