# 复习

## 一. vue中标签上的一些基本语法

1. 插值表达式

   ```vue
   {{ 表达式 / 变量 / 带有返回值的方法( 例如: fn() ) }}
   ```

2. v-bind 动态属性

   ```vue
   <span v-bind:属性名="属性值"></span>
   <span :属性名="属性值"></span>
   
   <子组件 :自定义属性名="属性值"></子组件>
   ```

3. v-on 绑定事件

   ```vue
   <span v-on:事件名="绑定该事件的方法"></span>
   <span v-on:click="fn"></span>
   <span @click="fn"></span>
   ```

4. v-on 的事件对象 event

   - 如果事件绑定的方法没有额外的实际参数，则在事件绑定时不必写 `小括号`，事件对象默认会放到第一个形参的位置上

     ```
     <span @click="fn"></span>
     
     fn (event) {}
     ```

   - 如果事件绑定的方法有额外的实际参数，以`$event`的形式，放到所有实际参数的最后面

     ```
     <span @click="fn(1, 2, 3, $event)"></span>
     
     fn (num1, num2, num3, event) {}
     ```

5. v-on的事件修饰符

   - once 绑定的事件只有第一次有效
   - **prevent** 阻止默认事件
   - **stop** 阻止冒泡（阻止事件委托）

6. v-on的按键修饰符 - 记录键盘按下的事件

   - esc 键盘左上角的返回键 - 清空输入框内容
   - enter 回车 - 自动提交表单

7. v-model - 用在表单元素上,实现数据与视图的双向绑定

8. v-model的修饰符

   - .trim 去除前后空格 
   - .number 只能输入数字，如果说最开始的那个字符不能解析为数字时，整个`.number`修饰符会失效
   - .lazy 输入框原本每做一次修改都会引起数据与视图的双向绑定，当设置了这个修饰符时，只有当输入框发生change事件(可以理解为：敲击回车，失焦)时，才去触发数据与视图的双向绑定

9. v-show v-if

   - v-show  是用过css样式`display: none`来显示隐藏和显示的
   - v-if v-else-if v-else 是通过删除和添加dom树来进行显示和隐藏的

   当需要显示和隐藏的结构均为静态数据时，那么选择v-show，除此以外均选择v-if

10. v-text 和 v-html

    - v-text => innerText
    - v-html => innerHTML

    当设置了这两个指令后，这个标签内不能写任何内容

11. v-for

    循环可遍历的数据结构，减少dom操作

    ```
    v-for="(value, index) in 数据结构" :key="index"
    ```

    在数据循环的过程中，需要为被循环的标签设置key属性，这个属性的设置规律： 有id用id，没id用索引，id报错用索引。

12. MVVM设计模式

    - 修改数据时，视图自动同步
    - 修改视图时，数据自动同步

    model - 数据模型 - 例：data中定义的数据

    view - 视图 - 例：表单控件

    viewModel - viewModel视图模型  vue内置的源码黑盒

13. MVC设计模式

    model - 数据模型 - 例：data中定义的数据

    view - 视图 - 例：表单控件

    controller 控制器

    通过方法或事件通知controller 控制器，又控制器去修改数据与视图(操作dom修改)

## 二. 进阶动态属性

1. 动态class类

   ```
   // 展示或隐藏特定类名
   :class="{ 类名: 布尔值 / 可隐式转化为布尔值类型的数据(变量和表达式) }"
   
   // 切换不同的类名
   :class="[ 携带样式类名的变量 ]"
   ```

2. 动态style

   ```
   // 特定样式属性进行样式转化
   :style="{ css样式属性名: 携带 当前样式属性专属的属性值 的变量 }"
   
   // 当需要切换不同种样式结构时
   :style="[ 以对象形式携带 样式属性(键值对) 的变量 ]"
   ```

## 三. 过滤器filter

> 转化页面中某些数据个格式。 过滤器就是一个函数，传入值并返回处理后的值，不会修改源数据

```
// 全局过滤器
Vue.filter('自定义过滤器名称', (需要过滤处理的数据源, 使用时传递过来的参数) => { return '返回处理后的值' })

// 局部过滤器
在data的同级
filers: {
	'自定义过滤器名称' (需要过滤处理的数据源, 使用时传递过来的参数) {
		return '返回处理后的值'
	}
}

=> 如果过滤时的处理方式并不复杂（一行代码搞定），可以直接在插值表达式中书写该逻辑即可，不必使用过滤器
```

## 四. 计算属性computed

> 场景：当页面上某一个变量会受到一个或多个变量的影响(计算)得来时，可以使用计算属性来实现代码的简化

特点： computed 计算属性存在缓存机制， 当依赖项没有发生改变时，去使用对应的计算属性，那么不会重复计算而是冲缓存中直接获取结果

```
// 基本写法
computed: {
	'计算属性名称' () {
		// 各个依赖项的处理逻辑
		return '计算后的值'
	}
}

// 完整写法 - 全选小选
computed: {
	'计算属性名称': {
		// 一般情况下，在表单控件中主动修改计算属性的值时，会触发set方法
		set (value) {
			value表示的是当前计算属性的值
		},
		// get方法就是基本写法的格式和作用
		get () {}
	}
}
```

## 五. 监听器 watch

> 场景： 当某个数据需要它修改时，去影响其他一个或多个数据时，可以使用监听器去监听当前数据的变化

特点： 监听器是一个对象，键时需要观察的变量属性，值是一个回调函数，主要用于监听某些特定数据的变化，从而进行某些具体的业务操作。监听操作对性能是有所消耗的，在使用时尽量少用。

```
// 基础写法
watch: {
	'被监听的变量名' (newVal, oldVal) {
		// 更新后的值 - newVal
		// 更新前的值 - oldVal
	}
}

// 当发现监听不到数据变化时改为深度监听
watch: {
	'被监听的变量名': {
		handler (newVal, oldVal) {
            // 更新后的值 - newVal
            // 更新前的值 - oldVal
        },
        deep: true, // 开启深度监听
        immediate: true // 当页面载入时立即执行一次监理handler的方法
	}
}

// 无论监听什么数据， 先用基本写法进行监听，如果监听不到数据的改变，则转化为深度监听
// 如果业务需求不需要比较新旧参数的变化时，可以不传任何参数
```

## 六. 组件通信

![image-20220929103208956](images/image-20220929103208956.png)

## 七. 组件的进阶用法

### 7.1 动态组件

1. 动态组件一定有is属性（必填）
2. is属性必须是动态属性，且它的属性值必须是一个变量
3. 记录组件名称的变量记录的是 components对象中注册的组件的属性名

```vue
<component :is="记录组件名称的变量"></component>
```

如果动态组件切换时希望浏览器能够记住切换前的组件状态，那么可以用`<keep-alive>`来进行组件缓存

```vue
<keep-alive>
	<component :is="记录组件名称的变量"></component>
</keep-alive>
```

### 7.2 组件插槽 - 工作中用的少

>  （当公司达到一定水平 - 你的薪资达到一定水平时，使用的频率才会上升）

1. 插槽的基本用法

   子组件

   1. 在需要自定义的位置上设置`<slot></slot>`插槽标签， 为父组件中灵活设置的结构占位

   ```vue
   <div>
       <slot></slot>
   </div>
   ```

   父组件

   1.  在子组件双标签中，设置对应性自定义结构，即可显示到子组件定义的插槽位置

   ```vue
   <child>
   	<div>自定义内容</div>
   </child>
   ```

2. 插槽的默认值

   > 场景: 又是其实在使用某个子组件时，会有一些公共相同的内容，而真正需要对该内容做出修改的机会比较少

   子组件

   1. 在原有`<slot></slot>`标签内，设置应有的默认结构即可

   ```vue
   <div>
       <slot>
       	默认值
       </slot>
   </div>
   ```

   父组件

   1. 如果需要用到子组件插槽的默认值，这不用在子组件的标签中设置任何内容即可

   ```vue
   <child></child>
   ```

3. 具名插槽

   > 场景： 当子组件中有多个位置都需要父组件来灵活配置时，可以为`slot`标签设置name属性。

   子组件

   1. 为`<slot>`标签设置name属性

   ```vue
   <div>
       <slot name="title"></slot>
       <slot name="content"></slot>
   </div>
   ```

   父组件

   1. 子组件的双标签中，以`<template></template>`中设置`v-slot:插槽名称 或者 #插槽名称`的方式来确定插入的位置

   ```vue
   <child>
   	<template v-slot:title></template>
       <template #title></template>
   </child>
   ```

4. 作用域插槽

   > 场景： 当父组件中子组件插槽部分需要用到某些子组件中的数据时，需要用作用域插槽进行参数的传递

   子组件

   1. 在`<slot>`标签中，设置 `:自定义属性="子组件中的数据变量"` 来进行插槽的参数传递

   ```vue
   <div>
       <slot name="title" :obj="myObj" :row="myRow"></slot>
   </div>
   ```

   父组件

   	1. 在原本具名插槽`<template v-slot:插槽名称 />`后以等号的形式，创建自定义变量（scope）， 该自定义变量以对象的形式包含了所有当前具名插槽中所设置的自定义属性及对应的值

   ```vue
   <child>
   	<template v-slot:title="scope">
   		{{ scope.obj }}
   		{{ scope.row }}
       </template>
   </child>
   ```

## 八. 生命周期

> 5个阶段 10个方法

1. 初始化阶段

   beforeCreate - 数据方法什么都没有，做不了操作

   **created** - 可以操作数据和方法(在此时可以调用接口获取数据，也可以定义全局事件和方法)

   ​				 不可以进行dom操作

2. 挂载阶段

   beforeMount - 可以进行操作与created相同，但时间相对滞后，所以一般不用

   **mounted** - 既可以操作数据和方法，也可以操作dom元素

   ​				 当你不太好确定某个方法是否需要进行dom操作时，就直接丢在mounted中

3. 激活阶段

   只有动态组件放在keep-alive中进行缓存时，才会触发激活阶段的钩子函数

   activated - 激活时，只要存在缓存，就将created和mounted中的逻辑放到这里即可

   deactivated - 失活时，如果当前组件存在定时器时，将beforeDestroy中的逻辑放到这里即可

4. 更新阶段

   beforeUpdate - 更新前，数据修改了，但页面没修改

   updated - 更新后，数据修改了，但页面也更新了

   问题：在更新阶段时，如果又对数据进行了修改操作，那么又会产生新的更新阶段，会有死循环的风险。 所有当我们需要对某个值变化时去影响其他的值时，使用watch监听器来进行即可

5. 销毁阶段

   **beforeDestroy** - 销毁前，可以进行数据方法的操作和dom元素的获取，在此时需要关闭定时器，计时器，异步操作等

   destroyed - 销毁后，数据方法和dom已经销毁掉了，不用做任何操作



## 九. axios

```
axios({
	method: 'GET',
	url: '',
	params: {}
})
// get请求的参数会记录到url上

axios({
	method: 'POST',
	url: '',
	data: {}
})
// post请求的参数只会记录到请求体中
```



## 十. $nextTick

> 场景： Vue页面DOM的更新是异步的 (数据与页面存在延时)， 正因为如此，我们无法在第一时间获取到最新的dom元素

```
this.$nextTick(() => {
	// dom更新后需要执行的代码逻辑
})
```

实现原理：  `$nextTick`是 在dom元素更新后所执行的回调函数，所以说`$nextTick`是dom异步更新的回调函数它本身不应该认为是异步方法

使用时：`$nextTick`需要写在函数执行体的最后



扩展： `setTimeout(() => {}, 0)`也能解决dom异步渲染后的业务操作

原理： 即使是异步操作，它也需要在异步操作的队列里等待前一个异步操作执行完成，所以说就可以创建一个新的异步方法放到原本dom更新的异步操作后，当dom更新异步操作完成以后，就可执行下一个异步方法了

## 十一. vue文件中的基本常识

### 11.1 组件中的data是一个函数

​			因为组件是可以拿来复用的，但js中的对象是引用关系，如果data是一个对象，当一个组件被复用时，那么每个组件会共同引用同一个对象，当一个组件中对这个对象中的数据进行修改时，那么另外一个组件中的数据也会被相应修改，这样会造成一个数据污染的问题；但是当data是一个函数的时候，组件被复用时，每复用一次data就会返回一个新的数据对象，这样每个被复用的组件就拥有各自的数据对象，就不会造成这个数据污染问题；



### 11.2 style标签中scoped属性的作用

作用： 让当前style标签中的样式属性只作用于当前的`template`模板标签中

原理：

1. 为每一个组件实例生成一个唯一的标识组件的标识符
2. 通过这个标识符，为`<template>`模板中的每一个dom元素以及在这个模板中的子组件的根标签设置以`data-v-`开头，后面接上唯一标识符的标签属性： 例如： `data-v-e0djsk23`
3. 在style标签上设置的各个css样式属性均会自动的在*选择器*的后面添加一个*属性选择器*`[data-v-e0djsk23]`，通过该操作就可以保证只有当前的这个组件会受到样式的影响

### 11.3 简单描述一下vue的设计模式

参考答案：

​		vue使用的mvvm设计模式；

​		MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel；Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁（vue实例） ；

​		数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。 双向绑定的描述；



### 11.4 简述nextTick实现原理

参考答案：

​		1. nextTick是Vue提供的一个全局API（内置方法），是下次DOM更新循环结束之后执行的延时回调，在修改之后使用$nextTick，则可以在回调中获取更新后的DOM进行对应的操作；

​		2.vue在更新DOM时是异步执行的。只要侦听到数据变化，vue将开启1个队列，并缓存在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会推入到队列中1次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的DOM操作完成后才调用。

### 11.5 计算属性computed与侦听器watch的区别

参考答案：

​		computed计算属性：该属性的结果会被缓存，当computed中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用computed中的函数必须用return返回最终的结果，computed更高效，优先使用

​		watch属性监听： 是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，监听属性的变化，需要在数据变化时执行异步或开销较大的操作使用。

​		使用场景：computed当一个属性受多个属性影响的时候使用 （多对一），例：购物车结算功能； watch当一条数据影响多条数据的时候使用（一对多），例：搜索数据。

## 十二. 路由 - （vue-router）

### 12.1 路由的创建

1. 下载vue-router依赖， 注意版本

   - vue2 => npm i vue-router@3.5.1
   - vue3 => npm i vue-router

2. 引入路由

   ```
   import VueRouter from 'vue-router'
   ```

3. 使用路由

   ```
   Vue.use(VueRouter)
   ```

4. 创建规则数组

   ```js
   // 引入组件
   import Demo from '@/Demo.vue'
   import Child from '@/Child.vue'
   import NotFound from '@/NotFound.vue'
   // 创建规则数组
   let routes = [
    	{
    		path: '/', // 根路由
           redirect: '/demo' // 重定向到目标路由
    	},
       {
           path: '/demo',
           component: Demo,
           children: [ // 子路由部分
               {
                   path: 'child',
                   component: Child
               }
           ]
       },
       {
           path: '*',
           component: NotFound
       }
   ]
   ```

5. 创建router实例对象

   ```
   let router = new VueRouter({
   	routes
   })
   ```

6. 在实例化Vue中引入路由

   ```
   New Vue({
   	router,
   	render: (h) => h(App)
   	....
   })
   ```

### 12.2 路由的使用

1. 声明式导航

   通过`router-link`标签实现编程式导航的路由跳转（相当于a标签）

   - 发送：`<router-link to="/path?属性名1=属性值1&属性名2=属性值2" />`

     接收：`$route.query.属性名`

   - 发送：`<router-link to="/path/属性值" />`

     ​			需要在路由规则数组中的path属性定义 `path: '/path/:属性名'`

     接收： `$route.params.属性名`

2. 编程式导航

   - 发送： `$router.push({ path: '/path', query: { 携带参数的键值对 } })`

     query传参的参数会记录在url上以`?属性名=属性值`的形式

     接收： `$route.query.属性名`

   - 发送： `$router.push({ name: 'pathName', params: { 携带参数的键值对 } })`

     params传参的参数不会记录到url上，并且刷新页面以后参数就会丢失

     接收： `$route.params.属性名`

3. 在组件中如何设置

   通过`<router-view></router-view>`标签来作为路由组件的替换标签，确定路由组件所影响的位置。

4. 路由的`meta`属性

   当某些路由需要携带一些**静态**数据时，可以不用通过路由传参来传递，可以设置在路由规则数组的meta属性下，那么当需要使用的时候，通过`$route.meta`来获取

   ```js
   let routes = [
   	{
   		path: '/home',
           component: Home,
           meta: {
               title: '首页',
               content: '推荐首页'
           }
   	}
   ]
   ```





## v-if 和 v-for🚩

​		1.优先级：在vue2中，v-for优先级大于v-if；在vue3中相反；

​		2.vue2中不建议两个语法在同一个标签中使用；

​				原因：两者一起用的时候，无论如何v-for都会先执行，做无谓的循环（因为最后有些都会被隐藏），对渲染性能不友好；

​		3.如果必须要使用，有以下两种解决办法：

​			(1)**当v-if的判断值不依赖v-for的数据时**，可以在外层先套一个<template>标签，让v-if先判断，再在内部进行v-for循环；

​			(2)**当v-if的判断值依赖于v-for循环的数据时**，可以在计算属性*computed*里面先进行数据的过滤，再用v-for循环计算属性；



## ES6 代码转成 ES5 代码的实现思路🚩

将ES6 转为ES5 主要用到的是Babel编译器， 参考Babel的实现方式。

那么 Babel 是如何把 ES6 转成 ES5 呢，其大致分为三步：

1. 解析：解析代码字符串，生成 AST(抽象语法树)；
2. 转换：按一定的规则转换、修改 AST，将ES6转换为ES5代码；
3. 生成：将修改后的 AST 转换成普通代码。



## XSS和CSRF（网络安全）🚩

Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击.

XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。

XSS的分类：

​		储存型：注入的脚本永久储存在服务器上，当浏览器发送请求时，脚本从服务器上传回并执行（论坛易受此类攻击）

​		反射型：恶意代码在客户端打开网页时暂时存在，动态网站和邮件应用容易受到此类攻击；

​		基于DOM型（本地XSS）：web服务器不参与，破坏是由客户端的脚本引起的

XSS的防御：

​		对输入过滤（过滤script标签）检查；输出处理，改成纯前端渲染，把数据和代码分开；不使用v-html；验证码；HttpOnly防止窃取Cookie；使用CSP（内容安全策略，实质上就是白名单制度）。



Cross-site request forgery 跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求. 利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的；

常见的CSRF攻击类型：GET类型的CSRF攻击类型（只需要发送一个HTTP请求）；POST类型的CSRF请求（利用的通常是一个自动提交的表单）；链接类型的CSRF类型（受害用户通过点击链接）。

CSRF防护：验证Header中的Referer确定来源域名；加入验证码；CSRF Token；加自定义的Header。



## 强制缓存和协商缓存(network)🚩

强缓存和协商缓存都是属于**浏览器缓存**

**强制缓存**：不会向服务器发送请求，直接在缓存中读取资源，可以在network中看到请求返回的状态码是200，而且响应头中有个cache-control属性的属性值为：`max-age=秒时间`（表示强缓存的时间）；

**协商缓存**：**在使用本地缓存之前需要向服务器发送请求**，服务器会根据请求头中的`If-Modify-Since/If-None-Match`的值(其值为上一次服务器发送给客户端响应头中的`Lsat-Modify/Etag`的值)来判断是否命中协商缓存，如果命中，则返回304状态码，并通过新的响应头通知浏览器从缓存中读取资源，如果没有命中，则返回状态码200并返回新的资源；**协商缓存是为了解决强制缓存下资源不更新问题的**，在协商缓存的响应头中有个cache-control属性的属性值为`-no-cache`。

协商缓存的两种模式：`Last-Modify和Etag`，Last-Modify的值是服务器返回给客户端资源最后一次被修改的时间（以秒计算）；而Etag的值是服务器根据资源通过算法生成的hash值；性能上来说 Etag 要逊于 Last-Modify，而资源获取的准确性来说 Etag 要优于 Last-Modify；



## 同源策略及跨域问题🚩

同源策略是**浏览器**为了安全起见，规定两个非同源的网站之间不允许相互访问对方的数据，同源策略只发生在响应回到浏览器的时候；非同源网站间不允许发送的数据：Cookie、DOM、ajax请求(`同源策略只针对ajax请求`，对 link、script、img等请求不限制)；

同源的条件：两个页面的**协议、域名 端口号**相同时，这两个页面就是同源，任何一个不同是就是非同源；

非同源访问数据 - 跨域，解决跨域方式：

​		jsonp：利用script发送请求，只能应用于get方式发送，不常用；

​		CORS：需要后端配合在响应头中添加对应的属性（工作中的一种方式）；

​		服务器跨域：工作中的另一种方式；

​		Nginx 反向代理：部署上线时采用



## 首屏加载时间过慢解决方法🚩

加载过慢的原因：

​		网络延迟、资源文件体积过大、资源是否重复请求、加载脚本的时候渲染内容堵塞等；

解决方法：

​		减少入口文件体积、静态资源本地缓存、UI框架按需加载、图片资源压缩、开启Gzip压缩、使用SSR服务端渲染；

​		1.减少入口文件体积的常用方式是：使用路由懒加载（用函数形式引入）

​		2.静态资源本地缓存：采用强缓存或协商缓存、合理的去利用本地储存localStorage;

​		3.不常用的UI框架按需加载；

​		4.图片资源也可以进行适当的压缩、使用精灵图、或者用requer懒加载的形式；

​		5.使用SSR服务端渲染；组件或页面通过服务器生成html字符串，再发送到浏览器；SSR还有利于SEO优化；



前端优化的方式：

```
1. 浏览器缓存
2. 防抖、节流
3. 资源懒加载、预加载
4.开启Nginx gzip压缩
三个方面来说明前端性能优化
一： webapck优化与开启gzip压缩
    1.babel-loader用 include 或 exclude 来帮我们避免不必要的转译，不转译node_moudules中的js文件
    其次在缓存当前转译的js文件，设置loader: 'babel-loader?cacheDirectory=true'
    2.文件采用按需加载等等
    3.具体的做法非常简单，只需要你在你的 request headers 中加上这么一句：
    accept-encoding:gzip
    4.图片优化，采用svg图片或者字体图标
    5.浏览器缓存机制，它又分为强缓存和协商缓存
二：本地存储——从 Cookie 到 Web Storage、IndexedDB
    说明一下SessionStorage和localStorage还有cookie的区别和优缺点
三：代码优化
    1.事件代理
    2.事件的节流和防抖
    3.页面的回流和重绘
    4.EventLoop事件循环机制
    5.代码优化等等
```



























