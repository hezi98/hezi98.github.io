## v-if 和 v-for🚩

​		1.优先级：在vue2中，v-for优先级大于v-if；在vue3中相反；

​		2.vue2中不建议两个语法在同一个标签中使用；

​				原因：两者一起用的时候，无论如何v-for都会先执行，做无谓的循环（因为最后有些都会被隐藏），对渲染性能不友好；

​		3.如果必须要使用，有以下两种解决办法：

​			(1)**当v-if的判断值不依赖v-for的数据时**，可以在外层先套一个`<template>`标签，让v-if先判断，再在内部进行v-for循环；

​			(2)**当v-if的判断值依赖于v-for循环的数据时**，可以在计算属性*computed*里面先进行数据的过滤，再用v-for循环计算属性；



## ES6 代码转成 ES5 代码的实现思路🚩

将ES6 转为ES5 主要用到的是Babel编译器， 参考Babel的实现方式。

那么 Babel 是如何把 ES6 转成 ES5 呢，其大致分为三步：

1. 解析：解析代码字符串，生成 AST(抽象语法树)；
2. 转换：按一定的规则转换、修改 AST，将ES6转换为ES5代码；
3. 生成：将修改后的 AST 转换成普通代码。



## XSS和CSRF（网络安全）🚩

Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击.

XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。

XSS的分类：

​		储存型：注入的脚本永久储存在服务器上，当浏览器发送请求时，脚本从服务器上传回并执行（论坛易受此类攻击）

​		反射型：恶意代码在客户端打开网页时暂时存在，动态网站和邮件应用容易受到此类攻击；

​		基于DOM型（本地XSS）：web服务器不参与，破坏是由客户端的脚本引起的

XSS的防御：

​		对输入过滤（过滤script标签）检查；输出处理，改成纯前端渲染，把数据和代码分开；不使用v-html；验证码；HttpOnly防止窃取Cookie；使用CSP（内容安全策略，实质上就是白名单制度）。



Cross-site request forgery 跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求. 利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的；

常见的CSRF攻击类型：GET类型的CSRF攻击类型（只需要发送一个HTTP请求）；POST类型的CSRF请求（利用的通常是一个自动提交的表单）；链接类型的CSRF类型（受害用户通过点击链接）。

CSRF防护：验证Header中的Referer确定来源域名；加入验证码；CSRF Token；加自定义的Header。



## 强制缓存和协商缓存(network)🚩

强缓存和协商缓存都是属于**浏览器缓存**

**强制缓存**：不会向服务器发送请求，直接在缓存中读取资源，可以在network中看到请求返回的状态码是200，而且响应头中有个cache-control属性的属性值为：`max-age=秒时间`（表示强缓存的时间）；

**协商缓存**：**在使用本地缓存之前需要向服务器发送请求**，服务器会根据请求头中的`If-Modify-Since/If-None-Match`的值(其值为上一次服务器发送给客户端响应头中的`Lsat-Modify/Etag`的值)来判断是否命中协商缓存，如果命中，则返回304状态码，并通过新的响应头通知浏览器从缓存中读取资源，如果没有命中，则返回状态码200并返回新的资源；**协商缓存是为了解决强制缓存下资源不更新问题的**，在协商缓存的响应头中有个cache-control属性的属性值为`-no-cache`。

协商缓存的两种模式：`Last-Modify和Etag`，Last-Modify的值是服务器返回给客户端资源最后一次被修改的时间（以秒计算）；而Etag的值是服务器根据资源通过算法生成的hash值；性能上来说 Etag 要逊于 Last-Modify，而资源获取的准确性来说 Etag 要优于 Last-Modify；



## 同源策略及跨域问题🚩

同源策略是**浏览器**为了安全起见，规定两个非同源的网站之间不允许相互访问对方的数据，同源策略只发生在响应回到浏览器的时候；非同源网站间不允许发送的数据：Cookie、DOM、ajax请求(`同源策略只针对ajax请求`，对 link、script、img等请求不限制)；

同源的条件：两个页面的**协议、域名 端口号**相同时，这两个页面就是同源，任何一个不同是就是非同源；

非同源访问数据 - 跨域，解决跨域方式：

​		jsonp：利用script发送请求，只能应用于get方式发送，不常用；

​		CORS：需要后端配合在响应头中添加对应的属性（工作中的一种方式）；

​		服务器跨域：工作中的另一种方式；

​		Nginx 反向代理：部署上线时采用



## 首屏加载时间过慢解决方法🚩

加载过慢的原因：

​		网络延迟、资源文件体积过大、资源是否重复请求、加载脚本的时候渲染内容堵塞等；

解决方法：

​		减少入口文件体积、静态资源本地缓存、UI框架按需加载、图片资源压缩、开启Gzip压缩、使用SSR服务端渲染；

​		1.减少入口文件体积的常用方式是：使用路由懒加载（用函数形式引入）

​		2.静态资源本地缓存：采用强缓存或协商缓存、合理的去利用本地储存localStorage;

​		3.不常用的UI框架按需加载；

​		4.图片资源也可以进行适当的压缩、使用精灵图、或者用requer懒加载的形式；

​		5.使用SSR服务端渲染；组件或页面通过服务器生成html字符串，再发送到浏览器；SSR还有利于SEO优化；



前端优化的方式：

```
1. 浏览器缓存
2. 防抖、节流
3. 资源懒加载、预加载
4.开启Nginx gzip压缩
三个方面来说明前端性能优化
一： webapck优化与开启gzip压缩
    1.babel-loader用 include 或 exclude 来帮我们避免不必要的转译，不转译node_moudules中的js文件
    其次在缓存当前转译的js文件，设置loader: 'babel-loader?cacheDirectory=true'
    2.文件采用按需加载等等
    3.具体的做法非常简单，只需要你在你的 request headers 中加上这么一句：
    accept-encoding:gzip
    4.图片优化，采用svg图片或者字体图标
    5.浏览器缓存机制，它又分为强缓存和协商缓存
二：本地存储——从 Cookie 到 Web Storage、IndexedDB
    说明一下SessionStorage和localStorage还有cookie的区别和优缺点
三：代码优化
    1.事件代理
    2.事件的节流和防抖
    3.页面的回流和重绘
    4.EventLoop事件循环机制
    5.代码优化等等
```

