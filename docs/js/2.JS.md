💡🚀🤟👉👇☀️🍉🍍🍇🍓🥕🍭🎖️🎁☘️🍀💯🔆❗🔥🚩

### 基本数据类型（5+2）🍓

1. 五种常用：string 、number、boolean、undefined、null
2. 两种不常见的：Symbol、BigInt

### 引用类型(6)

object、function、array、Math、RegExp、Date

### 检测数据类型（3）🍓

#### 1.typeof 

（1）语法：typeof  被检测数据

（2）只能检测基本简单类型，但是检测null的结果是 object 是个Bug；

（3）返回值是 string 型；

#### 2.instanceof

（1）语法：被检测数据  instanceof  Object/Array/Function

（2）只针对引用类型，其真实含义是：用于检测构造函数的 原型对象(**prototype**) 是否出现在某个实例的原型链上；

（3）返回值：Boolean；

#### 3.Object.protype.toString.call()

（1）语法：Object.protype.toString.call(被检测的数据)

（2）针对所有数据类型都可检测；

（3）返回值：字符串  样式：[object  类型]

### 生成随机数

生成 N-M 之间的随机整数：

```
  function getRandom(N, M) {
      return Math.floor(Math.random() * (M - N + 1)) + N
    }
```

### 比较 == 和 === 的区别

#### 1.双等号 ==

- 两个简单类型：字符串 和 布尔值 都会转换成数值，再比较（**只有**是一个字符串和一个数字/布尔值进行比较时字符串才会进行隐式转换）；
- 简单类型和引用类型：对象会通过 valueOf()方法取得原始值再根据简单类型比较原则相比较；
- 两个引用类型：比较它们是否指向同一个对象；
- null 与 undefined 返回 true;
- 存在NaN都返回false;

#### 2.三等号 ===

需要值与数据类型严格相等才返回 true，不会做数据转换；

null 与 undefined 返回 false;

区别：双等于会做类型转化再进行比较，全等则不会进行类型转换；

​				null 和 undefined 双等时ture , 全等时 false ；



### 垃圾回收+内存泄露

#### 1.垃圾回收

​		JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收，垃圾回收机制分为引用计数发和标记清楚法；

​		引用计数法：浏览器会跟踪记录每个值被引用的次数，当某个值的引用次数为0时，就会被回收；





### 事件流相关知识

#### 1.事件流

（1）含义：指的是事件完整执行过程中的流动路径,描述的是元素在页面中接收事件的顺序，包括三个阶段：捕获、目标、冒泡；

（2）addEventListener() 方法中的第三个参数就是控制该事件是哪个阶段，默认是false，表示冒泡阶段，如果设置为trun则表示捕获阶段；

#### 2.捕获阶段

（1）事件对象通过目标的祖先从窗口传播到目标的父级。这个阶段也称为捕获阶段，实际工作中用得较少；

#### 3.冒泡阶段

（1）事件对象以相反的顺序通过目标的祖先传播，从目标的父级开始，以Window结束，这个阶段也称为冒泡阶段。实际工作中用得较多。

#### 4.阻止冒泡/捕获

（1）代码：`e.stopPropagation()`

（2）阻止默认跳转代码：`e.preventDefault()`

#### 5.事件委托

（1）原理：利用事件冒泡原理，将事件绑定在公共父元素上面，通过公共父元素来监听事件。

（2）事件委托优点：减少事件注册的次数，提高程序性能能。

（3）事件监听中，this指向的是绑定事件的元素，`e.currentTarget === this`



### 深浅拷贝

#### 1.浅拷贝（4种方法）

含义：简单数据类型就拷贝值，引用数据类型拷贝内存地址，即只拷贝一层，深层次的不拷贝；

| 方式                                      | 解析                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| 扩展运算符                                | [...arr]  或 {...obj}                                        |
| Object.assign(targetObj, obj1, obj2, ...) | 返回值是一个对象（就是targetObj），不改变原对象，进行浅拷贝；也能对只有一个数组进行浅拷贝； |
| arr.slice(开始下标[, 结束下标])           | 直接对数组进行浅拷贝，返回新数组，包含开始下标的数组元素，不包含结束下标的元素； |
| arr.concat([需合并的数组或值])            | 将其他数组或值合并到arr中，不改变原数组，进行浅拷贝；        |

#### 2.深拷贝（三种方法）

含义：进行递归拷贝，拷贝前后两个对象互不影响；

| 方式           | 解析                                                  |
| -------------- | ----------------------------------------------------- |
| 手写递归函数   | 注意点：利用for in 循环，判断复杂类型时要先判断数组； |
| 插件 lodash.js | 使用其中的 `_.cloneDeep(obj)`，返回一个新对象；       |
| JSON字符串转换 | `JSON.parse(JSON.stringify(obj))`                     |

注：

​	JSON字符串深拷贝的缺点：

- 函数、undefined、Symbol 转换为 JSON 字符串后会丢失键值对；

- 拷贝正则表达式会变成空对象；

- 对象中含有 NaN、Infinity，会变成null；

- 拷贝 Date() 会变成字符串；

  

### 闭包

1.含义

​	两个函数相互嵌套，当内层函数调用到了外层函数中的变量时，外层函数被调用到的变量和内层函数就在外层函数中形成了一个空间；（闭包就是个特殊的代码结构）；

2.作用

让外层函数访问内层函数的变量

实现数据的私有化

3.缺点

会造成内存泄漏

4.使用场景

防抖、节流、实现柯里化（currying）函数



### 构造函数实例化的过程

(1)在构造函数内部创建一个空对象，并让this指向这个空对象；

(2)传参时执行函数中的代码，给创建的空对象增加属性及方法；

(3)执行完函数后返回该对象；



### 作用域和作用域链

作用域：函数或变量的可访问范围，包括：全局作用域、局部作用域，还有es6中的块级作用域；

作用域链：就是变量的查找机制，当访问一个变量时，JS引擎会先在当前作用域中去查找，如果当前作用域没有，则逐层往上去找；



### this指向问题

​			this是函数运行时自动生成的一个内部对象，只能在函数内部被使用；

(1) 默认绑定（非严格模式下）：

​			全局环境中定义的函数，其内部使用this时，this指向window;

(2) 隐式绑定：

​			当函数作为某个对象的方法被调用时，this一般指向调用它的上一层对象，且this永远指向最后调用它的对象（不管中间如何赋值）；

(3) 构造函数中this指向其实例对象，但构造函数new的过程中如果有返回值return,返回值是一个对象时，this指向这个返回对象，其余返回情况均指向实例对象；构造函数的静态成员方法中this指向的就是构造函数本身；

(4) 显示修改：

​			apply()、bind()、call()都会强制修改this的指向；

​			三者的区别：bind()不会立即调用函数，而call()和apply()会立即调用；

​								apply()接收的参数是一个数组，而bind()和call()接收的是参数列表；

(5) 箭头函数

​			箭头函数本身没有this，其中的this指向在书写时就已经确定了，指向的是其定义时候的上一层作用域的this值；

​			综上this指向的优先级：new绑定 > 显示绑定 > 隐式绑定 > 默认绑定

​	

### 原型及原型链

1.原型链是什么？

​		原型链其实就是对象属性和方法的查找规则；
2.内容：
  	(1)每个对象会通过 *_proto__*属性访问到它的原型对象，原型对象也有它的原型对象(原型里面也有__proto__属性，其指向最大的构造函数 Object() 的原型)；

​		(2)当访问一个对象的属性或方法时，会先去这个对象的自身寻找，如果自身没有，则会通过 __proto__ 这条链向上查找，一直找到最顶层的 Object.prototype 为止；

1.实例的 隐式原型(__proto__) 指向了其 构造函数的 显示原型(prototype);
2.构造函数的 显示原型 中的 隐式原型 指向的是 Object 的 显示原型(Object.prototype);
3.Object.prototype 中的 隐式原型 指向的是 null ；

总结：

1.所有引用数据类型(对象、数组、函数)都具有对象的特性，可以自由扩展属性和方法；
2.所有的对象都有一个 __proto__ 属性(隐式原型)，其指向它的构造函数的显示原型(prototype)；
3.所有函数都有一个 prototype 属性(显示原型)，属性值是一个普通对象(所以里面也有__proto__属性)；
4.当需要获取某个对象的属性或方法时，会先去这个对象本身去获取，如果本身没有，则会通过它的 __proto__  去它的构造函数中的原型对象中去查找；



### 地址栏输入 URL 敲下回车后发生了什么

1.url解析：判断输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行对应操作；

2.DNS查询：DNS其实就是个数据库，里面放了许多一一对应的url和IP地址，DNS查询会根据输入的url查询到对应的IP地址，从而对对应的服务器进行访问；

3.TCP连接：客户端与服务器正式发送数据之前会进行TCP通道连接，以后发送数据都会在这个TCP连接通道里面进行，这样保证数据的有序传送；

​	TCP连接会进行“三次握手”：

​			第一次：客户端向服务器发送SYN数据包来表示请求连接；

​			第二次：服务器会响应SYN数据包和ACK数据包表示同意连接；

​			第三次：客户端发送ACK数据包表示连接成功；

4.发送HTTP请求：先向服务器发送一个http请求，请求成功后响应请求，拿到html代码后开始解析代码；当解析遇

到link,script,img标签时，再发出http请求(有多少个标签就发多少个请求)；发出请求后一般不会等待响应回来，而

是继续往下解析html代码；等css,js,img响应回来后就开始解析并执行css,js代码，或将图片渲染到页面中；

















