💡🚀🤟👉👇☀️🍉🍍🍇🍓🥕🍭🎖️🎁☘️🍀💯🔆❗🔥🚩

### 基本数据类型（5+2）🍓

1. 五种常用：string 、number、boolean、undefined、null
2. 两种不常见的：Symbol、BigInt

### 引用类型(6)

object、function、array、Math、RegExp、Date

### 检测数据类型（3）🍓

#### 1.typeof 

（1）语法：typeof  被检测数据

（2）只能检测基本简单类型，但是检测null的结果是 object 是个Bug；

（3）返回值是 string 型；

#### 2.instanceof

（1）语法：被检测数据  instanceof  Object/Array/Function

（2）只针对引用类型，其真实含义是：用于检测构造函数的 原型对象(**prototype**) 是否出现在某个实例的原型链上；

（3）返回值：Boolean；

#### 3.Object.protype.toString.call()

（1）语法：Object.protype.toString.call(被检测的数据)

（2）针对所有数据类型都可检测；

（3）返回值：字符串  样式：[object  类型]

### 生成随机数

生成 N-M 之间的随机整数：

```
  function getRandom(N, M) {
      return Math.floor(Math.random() * (M - N + 1)) + N
    }
```

### 比较 == 和 === 的区别

#### 1.双等号 ==

- 两个简单类型：字符串 和 布尔值 都会转换成数值，再比较（**只有**是一个字符串和一个数字/布尔值进行比较时字符串才会进行隐式转换）；
- 简单类型和引用类型：对象会通过 valueOf()方法取得原始值再根据简单类型比较原则相比较；
- 两个引用类型：比较它们是否指向同一个对象；
- null 与 undefined 返回 true;
- 存在NaN都返回false;

#### 2.三等号 ===

需要值与数据类型严格相等才返回 true，不会做数据转换；

null 与 undefined 返回 false;

区别：双等于会做类型转化再进行比较，全等则不会进行类型转换；

​				null 和 undefined 双等时ture , 全等时 false ；



### 垃圾回收+内存泄露

#### 1.垃圾回收

​		JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收，垃圾回收机制分为**引用计数法**和**标记清除法**；

​		引用计数法：浏览器会跟踪记录每个值被引用的次数，当某个值的引用次数为0时，就会被回收；**缺点是**比如当两个对象相互引用时，变量就不会被清除，会造成内存泄漏，现在已经淘汰了；

​		标记清除法：浏览器从根部（JS全局域）出发定时扫描内存中的对象，凡是能从根部访问达到的对象，就是还需要用的；反之，不能访问到的对象被标记不再使用，进行回收；**缺点是**会造成**内存碎片化**，为了解决内存碎片化，需要配合**标记整理法**来进行清除；

#### 1.内存泄漏

用不到的内存没有被及时释放，就会造成内存泄漏

闭包会引起内存泄漏问题，除了闭包，还有意外申明全局变量、定时器setInterval ，也容易造成内存泄漏；



### 闭包的作用、缺陷、使用场景

1.含义：内层函数引用外层函数变量的集合；

2.缺陷：会造成内存泄漏；

3.作用：

​	1.让外层函数访问内层函数的变量            

​	2.实现数据的私有化；

4.使用场景：

1. 节流和防抖
2. 实现柯里化（currying）函数









### 事件流相关知识

#### 1.事件流

（1）含义：指的是事件完整执行过程中的流动路径,描述的是元素在页面中接收事件的顺序，包括三个阶段：捕获、目标、冒泡；

（2）addEventListener() 方法中的第三个参数就是控制该事件是哪个阶段，默认是false，表示冒泡阶段，如果设置为trun则表示捕获阶段；

#### 2.捕获阶段

（1）事件对象通过目标的祖先从窗口传播到目标的父级。这个阶段也称为捕获阶段，实际工作中用得较少；

#### 3.冒泡阶段

（1）事件对象以相反的顺序通过目标的祖先传播，从目标的父级开始，以Window结束，这个阶段也称为冒泡阶段。实际工作中用得较多。

#### 4.阻止冒泡/捕获

（1）代码：`e.stopPropagation()`

（2）阻止默认跳转代码：`e.preventDefault()`

#### 5.事件委托

（1）原理：利用事件冒泡原理，将事件绑定在公共父元素上面，通过公共父元素来监听事件。

（2）事件委托优点：减少事件注册的次数，提高程序性能能。

（3）事件监听中，this指向的是绑定事件的元素，`e.currentTarget === this`



### 事件循环 event loop

​		1.首先因为JS是单线程语言，所以同一时间只能做一件事情，为了解决这个问题，就出现了同步任务和异步任务；

​		2.当JS运行时会将代码分为同步任务和异步任务，同步任务直接进入执行栈执行，而异步任务会被放入异步进程里面进行处理，当满足异步任务触发的条件时，就将其放入任务队列；

​		3.而任务队列又分为**宏任务和微任务**，常见的`宏任务`有整个**script里面的代码、setTimeout()、setInterval()、I/O、UI Rendering**等，常见的`微任务`就是**promise实例的(then、catch、finally)、process.nextTick(与普通微任务有区别，在微任务队列执行之前执行)、MutationObserver(html5新特性)**；

​		4.整个**事件循环的过程**就是：JS运行时先执行完全部的同步任务，然后到微任务队列里面检查是否有判断出来的微任务，有就执行完所有的微任务（按照先进先出的原则，没有就直接去宏任务队列里面将宏任务放到执行栈执行）；当执行完所有上次判断出来的微任务后，就去宏任务队列里面将一条宏任务放到执行栈里面执行，执行完后又去微任务队列判断是否有新判断出来的微任务，有的话就又执行所有的微任务再去宏任务队列，然后重复以上步骤；总之，宏任务每次只执行一个，而微任务一次会执行完所有的；这就是我理解的事件循环；



### 深浅拷贝

#### 1.浅拷贝（4种方法）

含义：简单数据类型就拷贝值，引用数据类型拷贝内存地址，即只拷贝一层，深层次的不拷贝；

| 方式                                      | 解析                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| 扩展运算符                                | [...arr]  或 {...obj}                                        |
| Object.assign(targetObj, obj1, obj2, ...) | 返回值是一个对象（就是targetObj），不改变原对象，进行浅拷贝；也能对只有一个数组进行浅拷贝； |
| arr.slice(开始下标[, 结束下标])           | 直接对数组进行浅拷贝，返回新数组，包含开始下标的数组元素，不包含结束下标的元素； |
| arr.concat([需合并的数组或值])            | 将其他数组或值合并到arr中，不改变原数组，进行浅拷贝；        |

#### 2.深拷贝（三种方法）

含义：进行递归拷贝，拷贝前后两个对象互不影响；

| 方式           | 解析                                                  |
| -------------- | ----------------------------------------------------- |
| 手写递归函数   | 注意点：利用for in 循环，判断复杂类型时要先判断数组； |
| 插件 lodash.js | 使用其中的 `_.cloneDeep(obj)`，返回一个新对象；       |
| JSON字符串转换 | `JSON.parse(JSON.stringify(obj))`                     |

注：

​	JSON字符串深拷贝的缺点：

- 函数、undefined、Symbol 转换为 JSON 字符串后会丢失键值对；

- 拷贝正则表达式会变成空对象；

- 对象中含有 NaN、Infinity，会变成null；

- 拷贝 Date() 会变成字符串；

  

### 闭包

1.含义

​	两个函数相互嵌套，当内层函数调用到了外层函数中的变量时，外层函数被调用到的变量和内层函数就在外层函数中形成了一个空间；（闭包就是个特殊的代码结构）；

2.作用

让外层函数访问内层函数的变量

实现数据的私有化

3.缺点

会造成内存泄漏

4.使用场景

防抖、节流、实现柯里化（currying）函数



### 构造函数实例化的过程

(1)在构造函数内部创建一个空对象，并让this指向这个空对象；

(2)传参时执行函数中的代码，给创建的空对象增加属性及方法；

(3)执行完函数后返回该对象；



### 作用域和作用域链

作用域：函数或变量的可访问范围，包括：全局作用域、局部作用域，还有es6中的块级作用域；

作用域链：就是变量的查找机制，当访问一个变量时，JS引擎会先在当前作用域中去查找，如果当前作用域没有，则逐层往上去找；



### this指向问题

​			this是函数运行时自动生成的一个内部对象，只能在函数内部被使用；

(1) 默认绑定（非严格模式下）：

​			全局环境中定义的函数，其内部使用this时，this指向window;

(2) 隐式绑定：

​			当函数作为某个对象的方法被调用时，this一般指向调用它的上一层对象，且this永远指向最后调用它的对象（不管中间如何赋值）；

(3) 构造函数中this指向其实例对象，但构造函数new的过程中如果有返回值return,返回值是一个对象时，this指向这个返回对象，其余返回情况均指向实例对象；构造函数的静态成员方法中this指向的就是构造函数本身；

(4) 显示修改：

​			apply()、bind()、call()都会强制修改this的指向；

​			三者的区别：bind()不会立即调用函数，而call()和apply()会立即调用；

​								apply()接收的参数是一个数组，而bind()和call()接收的是参数列表；

(5) 箭头函数

​			箭头函数本身没有this，其中的this指向在书写时就已经确定了，指向的是其定义时候的上一层作用域的this值；

​			综上this指向的优先级：new绑定 > 显示绑定 > 隐式绑定 > 默认绑定

​	

### 原型及原型链

1.原型链是什么？

​		原型链其实就是对象属性和方法的查找规则；
2.内容：
  	(1)每个对象会通过 *_proto__*属性访问到它的原型对象，原型对象也有它的原型对象(原型里面也有__proto__属性，其指向最大的构造函数 Object() 的原型)；

​		(2)当访问一个对象的属性或方法时，会先去这个对象的自身寻找，如果自身没有，则会通过 __proto__ 这条链向上查找，一直找到最顶层的 Object.prototype 为止；

1.实例的 隐式原型(__proto__) 指向了其 构造函数的 显示原型(prototype);
2.构造函数的 显示原型 中的 隐式原型 指向的是 Object 的 显示原型(Object.prototype);
3.Object.prototype 中的 隐式原型 指向的是 null ；

总结：

1.所有引用数据类型(对象、数组、函数)都具有对象的特性，可以自由扩展属性和方法；
2.所有的对象都有一个 __proto__ 属性(隐式原型)，其指向它的构造函数的显示原型(prototype)；
3.所有函数都有一个 prototype 属性(显示原型)，属性值是一个普通对象(所以里面也有__proto__属性)；
4.当需要获取某个对象的属性或方法时，会先去这个对象本身去获取，如果本身没有，则会通过它的 __proto__  去它的构造函数中的原型对象中去查找；



### 地址栏输入 URL 敲下回车后发生了什么

1.url解析：判断输入的是一个合法的 URL 还是一个待搜索的关键词，如果是关键词，则将浏览器的默认搜索引擎加上关键词合成url进行搜索，如果是合法的url则进行DNS查询；

2.DNS查询：DNS其实就是个数据库，里面放了许多一一对应的url和IP地址，DNS查询会根据输入的url查询到对应的IP地址，从而对对应的服务器进行访问；

3.TCP连接：客户端与服务器正式发送数据之前会进行TCP通道连接，以后发送数据都会在这个TCP连接通道里面进行，这样保证数据的有序传送；

​	TCP连接会进行“三次握手”：

​			第一次：客户端向服务器发送SYN数据包，表示请求连接（客户端能正常发送数据）；

​			第二次：服务器会响应SYN数据包和ACK数据包，表示同意连接（服务器能正常接收和发送数据）；

​			第三次：客户端发送ACK数据包，表示连接成功（客户端能正常接收数据）；

4.发送HTTP请求：先向服务器发送一个http请求，请求成功后响应请求，拿到html代码后开始解析代码；当解析遇

到link,script,img标签时，再发出http请求(有多少个标签就发多少个请求)；发出请求后一般不会等待响应回来，而

是继续往下解析html代码，等响应回来后就开始解析并执行对应的代码，或将对应的资源渲染到页面中；



### 说一说Promise

​		1.promise是ES6新增的一个构造函数，它主要就是解决异步编程的回调地狱问题，将回调地狱的形式书写为*.then*的链式调用；

​		2.他有三个状态：pending(待定)、fulfilled(已成功)、rejected(已失败)，这三个状态值一旦改变了就不会再有变化；

​		3.Promise接收一个回调函数作为参数，回调函数里面有resolve、reject两个方法作为参数，执行resolve()就会将panding的状态值变为fulfilled，执行reject()就会将panding的状态值变为rejected；

​		4.then()方法是promise实例状态发生改变时调用的回调函数，接收两个参数，第一个是resolved状态的回调函数，第二个参数是rejected状态的回调函数，但我们一般用catch()方法替代rejected状态的回调函数；

​		5.然后ES6也新增了 async()、await()方法更加简化了promise链式调用的语法；

​		6.Promise的静态方法：

Promise.resolve()   Promise.rejected()

Promise.all()   =>  接收`多个promise实例组成的数组`作为参数，只有当所有实例的状态都变为fulfilled的时候，才会执行这个方法的then()方法；其中一个状态为rejected时，执行catch();

此外还有：Promise.allSettled()、Promise.race()、Promise.any()；



### 数组去重的方式有哪些？

1. **双重for遍历数组**

```
 for (let i = 0; i < arr.length; i++) {
            for (let j = i + 1; j < arr.length; j++) {
                if (arr[i] === arr[j]) {
                    arr.splice(j, 1)
                }
            }
        }
```

1. **includes（）**

```
const newArr = []
       for (let i = 0; i < arr.length; i++) {
           if (!newArr.includes(arr[i])) {
               newArr.push(arr[i])
           }
       }
```

1. **indexof（）**

```
const newArr = []
       for (let i = 0; i < arr.length; i++) {
           if (newArr .indexOf(arr[i]) === -1) {
               newArr .push(arr[i])
           }
       }
```

1. **findIndex（）**

```
const newArr= []
        for (let i = 0; i < arr.length; i++) {
            if (newArr.findIndex(el => el === arr[i]) === -1) {
                newArr.push(arr[i])
            }
        }
```

1. **Set**

```
const newArr= Array.from(new Set(arr))
```

1. **reduce（）**

```
const newArr= arr.reduce((pre, cur) => {
           if (!pre.includes(cur)) {
               pre.push(cur)
           }
           return pre
       }, [])
```







